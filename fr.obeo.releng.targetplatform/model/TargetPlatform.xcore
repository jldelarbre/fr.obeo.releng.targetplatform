@GenModel(prefix="TargetPlatform", modelName="TargetPlatform")
package fr.obeo.releng.targetplatform

import com.google.common.base.Splitter
import java.util.List
import java.util.Locale
import java.util.UUID
import org.eclipse.core.runtime.Platform
import org.eclipse.emf.common.util.DelegatingEList$UnmodifiableEList
import org.eclipse.jdt.launching.JavaRuntime
import org.eclipse.xtext.nodemodel.impl.RootNode
import org.eclipse.core.runtime.Status
import org.eclipse.core.runtime.IStatus

class TargetPlatform {
	String name
	
	// For optimisation purpose: Once composite element have been resolved, if the target is accessed again: we do not repeat the operation
	boolean compositeElementsResolved = "false"
	// A target could be modified when resolving composite elements or by importing variable from included target
	// Used to determine if weather or not we have to force reload the target
	boolean modified = "false"
	
	contains VarDefinitionContainer preDefinedVarContainer
	
	// To understand the usage of varDef2OverrideInImportedTarget see tests: TestOverrideImportTarget.testOverrideRecursive
	// and TestOverrideImportTarget.testOverrideRecursiveWithJump
	// In the second test, the intermediate tpd has no varDefinition, so we have to propagate them through the
	// intermediate target
	contains VarDefinition[] varDef2OverrideInImportedTarget
	
	contains TargetContent[] contents opposite targetPlatform
	  
	refers derived IncludeDeclaration[] includes get {
		new UnmodifiableEList(contents.filter(typeof(IncludeDeclaration)).toList)
	}
	derived Option[] options get {
		new UnmodifiableEList(contents.filter(typeof(Options)).map[options].flatten.toList)
	}
	refers derived Location[] locations get {
		new UnmodifiableEList(contents.filter(typeof(Location)).toList)
	}
	refers derived Environment environment get {
		contents.filter(typeof(Environment)).head
	}
	refers derived VarDefinition[] varDefinition get {
		new UnmodifiableEList(contents.filter(typeof(VarDefinition)).toList)
	}
}

interface TargetContent {
	container TargetPlatform targetPlatform opposite contents
}

class Options extends TargetContent {
	Option[] options
}

class Environment extends TargetContent {
	String[] env
	
	derived String operatingSystem get {
		val envToUpper = targetPlatform.contents.filter(typeof(Environment)).map[env].flatten.filter[!nullOrEmpty].map[toUpperCase].toList
		return 
			Platform.knownOSValues.findFirst[
				envToUpper.contains(it.toUpperCase)
			]
	}
	
	derived String windowingSystem get {
		val envToUpper = targetPlatform.contents.filter(typeof(Environment)).map[env].flatten.filter[!nullOrEmpty].map[toUpperCase].toList
		val knownWSUpperValues = Platform.knownWSValues.map[toUpperCase]
		
		val allWS = envToUpper.filter[
			knownWSUpperValues.contains(it)
		].toList
		
		if (allWS.size <= 1 && allWS.contains(operatingSystem?.toUpperCase)) {
			// case for win32 which is an os and an ws. Let's consider the first one 
			// as the os and the second as ws
			return null
		} else {
			return 
				Platform.knownWSValues.findFirst[
					envToUpper.contains(it.toUpperCase)
				]
		}
	}
	
	derived String architecture get {
		val envToUpper = targetPlatform.contents.filter(typeof(Environment)).map[env].flatten.filter[!nullOrEmpty].map[toUpperCase].toList
		return Platform.knownOSArchValues.findFirst[
			envToUpper.contains(it.toUpperCase)
		]
	}
	
	derived Locale localization get {
		val envToUpper = targetPlatform.contents.filter(typeof(Environment)).map[env].flatten.filter[!nullOrEmpty].map[toUpperCase].toList
		val locale = Locale.availableLocales.map[toString].findFirst[
			envToUpper.contains(it.toUpperCase)
		]
		
		if (locale !== null) {
			var String language = "";
			var String country = "";
			var String variant = "";
	
			val tokens = Splitter.on('_').trimResults.split(locale).iterator;
			if (tokens.hasNext) {
				language = tokens.next
			}
			if (tokens.hasNext) {
				country = tokens.next
			}
			if (tokens.hasNext) {
				variant = tokens.next
			}
	
			return new Locale(language, country, variant);
		} else {
			return null;
		}
	}
	
	derived ExecutionEnvironment executionEnvironment get {
		val eeManager = JavaRuntime.executionEnvironmentsManager
		if (eeManager !== null) {
			val envToUpper = targetPlatform.contents.filter(typeof(Environment)).map[env].flatten.filter[!nullOrEmpty].map[toUpperCase].toList
			
			for (env : envToUpper) {
				val ee = eeManager.executionEnvironments.findFirst[it.id.toUpperCase.equals(env)]
				if (ee !== null) {
					return ee
				}
			}
			
			return null
		} else {
			return null
		}
	}
}

type UUID wraps UUID

class VarDefinition extends TargetContent {
	String name
	contains CompositeString value
	boolean constant = "false"
	
	String overrideValue
	
	boolean variableDefinitionCycleDetected = "false"
	VarDefList varDefCycle
	
	boolean imported = "false" //true if the "variable definition" comes from an included tpd
	String[] importedValues //If the variable is included from many tpd, we list every encountered values
	UUID _sourceUUID //if a varDefinition is imported from a target and hence copied, it gets the UUID of the original verDef
	boolean diamondInherit = "false"
	
	/**
	 * return true if the variable is wholly defined inside the target where it is declared.
	 * 
	 * target "A"
	 * include "B"
	 * define a = "foo" + ${b}
	 * ----------------------
	 * target "B"
	 * define b = "bar"
	 * ----------------------
	 * 
	 * The variable "a" shall returned false
	 */
	op boolean isWhollyDefinedByTarget() {
		checkVarCycle()
		if (variableDefinitionCycleDetected) {
			return false
		}
		return isWhollyDefinedByTargetNoCycleChecked
	}
	
	op boolean isWhollyDefinedByTargetNoCycleChecked() {
		return value.stringParts.forall[
			if (it instanceof StaticString) {
				return true
			}
			else if (it instanceof VarCall) {
				val calledVarDef = it.varName
				if (calledVarDef?.name === null) {
					return false
				}
				if (calledVarDef.imported) {
					return false
				}
				return calledVarDef.isWhollyDefinedByTargetNoCycleChecked
			}
			return false
		]
	}
	
	op void checkVarCycle() {
		variableDefinitionCycleDetected = false
		varDefCycle = newArrayList
		varDefCycle.add(this)
		value.computeActualString(varDefCycle)
		
		variableDefinitionCycleDetected = value.variableDefinitionCycleDetected
		if (variableDefinitionCycleDetected) {
			varDefCycle = newArrayList(value.varDefCycle)
		}
		else {
			varDefCycle = newArrayList
		}
	}
	
	op String getEffectiveValue() {
		val alreadyCalledVariable = newArrayList
		return getEffectiveValue(alreadyCalledVariable)
	}
	
	op String getEffectiveValue(VarDefList alreadyCalledVariable) {
		// Is variable override
		if (overrideValue === null) {
			// Is the variable called exist
			if (value !== null) {
				val stringOutput = value.computeActualString(alreadyCalledVariable)
				variableDefinitionCycleDetected = value.variableDefinitionCycleDetected
				if (variableDefinitionCycleDetected) {
					varDefCycle = newArrayList(value.varDefCycle)
					return ""
				}
				return stringOutput
			}
			return "";
		}
		return overrideValue
	}
	
	op UUID getSourceUUID() {
		if (_sourceUUID === null) {
			val parentTargetPlatform = this.eContainer as TargetPlatform
			var targetContent = ""
			if (parentTargetPlatform.eAdapters.head instanceof RootNode) {
				targetContent = (parentTargetPlatform.eAdapters.head as RootNode).completeContent
			}
			val stringId = name + "___" + parentTargetPlatform.eResource.URI + "___" + targetContent
			_sourceUUID = UUID.nameUUIDFromBytes(stringId.bytes)
		}
		_sourceUUID
	}
	
	/* Recreate "toString" generated by xcore but avoid infinite loop if the
	 * define variable has a self recursive definition. */
	op String toString() {
		
		var result = new StringBuffer(super.toString());
		result.append(" (name: ")
		result.append(name)
		result.append(", overrideValue: ")
		result.append(overrideValue)
		result.append(", variableDefinitionCycleDetected: ")
		result.append(variableDefinitionCycleDetected)
		result.append(')')
		
		return result.toString()
	}
}

class VarDefinitionContainer {
	String name
	VarDefList varDefList
}

type VarDefList wraps List<VarDefinition>

class CompositeString {
	String name = "composite string"
	contains CompositeStringPart[] stringParts opposite compositeString
	boolean variableDefinitionCycleDetected = "false"
	VarDefList varDefCycle
	
	op String computeActualString() {
		val List<VarDefinition> alreadyCalledVariable = newArrayList
		return computeActualString(alreadyCalledVariable)
	}
	
	op String computeActualString(VarDefList alreadyCalledVariable) {
		variableDefinitionCycleDetected = false
		var result = new String
		for (CompositeStringPart stringPart : stringParts) {
			val List<VarDefinition> newAlreadyCalledVariable = newArrayList(alreadyCalledVariable)
			result += stringPart.getActualString(newAlreadyCalledVariable)
			if (stringPart.variableDefinitionCycleDetected) {
				variableDefinitionCycleDetected = stringPart.variableDefinitionCycleDetected
				varDefCycle = newArrayList(stringPart.varDefCycle)
				return ""
			}
		}
		return result
	}
	
	op CompositeString getCopy() {
		var output = TargetPlatformFactory.eINSTANCE.createCompositeString
		val stringPartsCopy = output.stringParts
		stringParts.forEach[
			stringPartsCopy.add(it.copy)
		]
		return output
	}
	
	/** Check if any components (and sub components) are resolved => any variable call are resolved: a value can be computed */
	op boolean isResolved() {
		return stringParts.forall[
			it.isResolved
		]
	}
}

interface CompositeStringPart {
	container CompositeString compositeString opposite stringParts
	
	op String getActualString()
	
	op String getActualString(VarDefList alreadyCalledVariable)
	
	op boolean isVariableDefinitionCycleDetected()
	
	op VarDefList getVarDefCycle()
	
	op CompositeStringPart getCopy()
	
	op boolean isResolved()
}

class VarCall extends CompositeStringPart {
	refers VarDefinition varName
	refers VarDefinition originalVarName
	boolean variableDefinitionCycleDetected = "false"
	VarDefList varDefCycle
	
	op String getActualString() {
		val alreadyCalledVariable = newArrayList
		return getActualString(alreadyCalledVariable)
	}
	
	op String getActualString(VarDefList alreadyCalledVariable) {
		if (null === varName) {
			var context = "Context: "
			var superContext = this.eContainer
			while (superContext !== null) {
				context += superContext.toString + " / "
				superContext = superContext.eContainer
			}
			
			val message = "The VarCall.varName can not be resolved by EMF.\n" + context;
			val e = new NullPointerException(message);
			TargetPlatformBundleActivator.getInstance().getLog()
					.log(new Status(IStatus.ERROR, TargetPlatformBundleActivator.PLUGIN_ID, message, e));
			return "";
		}
		
		// Cycle detection at this stage
		variableDefinitionCycleDetected = false;
		if (varName.value !== null) {
			if (alreadyCalledVariable.contains(varName)) {
				variableDefinitionCycleDetected = true;
			}
			alreadyCalledVariable.add(varName)
			if (variableDefinitionCycleDetected) {
				varDefCycle = newArrayList(alreadyCalledVariable)
				return ""
			}
		}
		val varNameEffectiveValue = varName.getEffectiveValue(alreadyCalledVariable)
		variableDefinitionCycleDetected = varName.variableDefinitionCycleDetected
		if (variableDefinitionCycleDetected) {
			varDefCycle = newArrayList(varName.varDefCycle)
		}
		return varNameEffectiveValue
	}
	
	// Override in fr.obeo.releng.targetplatform.impl
	op VarCall getCopy()
	
	op boolean isResolved() {
		if (varName === null) {
			return false
		}
		if (varName.name === null || varName.value === null) {
			return false
		}
		this.actualString // Force to check cycle if exist
		if (variableDefinitionCycleDetected) {
			return false
		}
		return varName.value.isResolved
	}
}

class StaticString extends CompositeStringPart {
	String value
	boolean variableDefinitionCycleDetected = "false"
	VarDefList varDefCycle
	
	op String getActualString() {
		varDefCycle = newArrayList
		return value
	}
	
	op String getActualString(VarDefList alreadyCalledVariable) {
		return getActualString()
	}
	
	op StaticString getCopy() {
		val output = TargetPlatformFactory.eINSTANCE.createStaticString
		output.value = value
		return output
	}
	
	op boolean isResolved() {
		return true
	}
}

type Locale wraps java.util.Locale
type ExecutionEnvironment wraps org.eclipse.jdt.launching.environments.IExecutionEnvironment

class Location extends TargetContent {
	String ID
	String uri
	contains CompositeString compositeUri
	Option[] options
	contains IU[] ius opposite location
	
	
	// Override in fr.obeo.releng.targetplatform.impl
	op void resolveUri()
	
	op void resolveIUsVersion() {
		for (IU iu : ius) {
			if (iu.version === null) {
				if (iu.varVersion !== null) {
					iu.version = iu.varVersion.actualString
				}
			}
		}
	}
}

class IncludeDeclaration extends TargetContent {
	String name = "include declaration"
	contains CompositeString compositeImportURI
	
	String importURI
	
	// Override in fr.obeo.releng.targetplatform.impl
	op void generateImportURI()
	
	op boolean isResolved() {
		return compositeImportURI.isResolved
	}
}

class IU {
	String ID
	String version
	contains VarCall varVersion
	container Location location opposite ius
}

enum Option {
	INCLUDE_REQUIRED as 'requirements' = 0 
	INCLUDE_ALL_ENVIRONMENTS as 'allEnvironments' = 1 
	INCLUDE_SOURCE as 'source' = 2
	INCLUDE_CONFIGURE_PHASE as 'configurePhase' = 3
}